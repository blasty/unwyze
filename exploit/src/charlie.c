#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stddef.h>
#include <assert.h>

#include "util.h"

uint8_t g_charlie_key[16] = {
    'C', 'h', 'a', 'r',
    'l', 'i', 'e', ' ',
    'i', 's', ' ', 't',
    'h', 'e', ' ', 'd'};

#define K0 *(uint32_t *)(g_charlie_key + 0)
#define K1 *(uint32_t *)(g_charlie_key + 4)
#define K2 *(uint32_t *)(g_charlie_key + 8)
#define K3 *(uint32_t *)(g_charlie_key + 12)

#define B0(x) (x & 0xff)
#define B1(x) ((x >> 8) & 0xff)
#define B2(x) ((x >> 16) & 0xff)
#define B3(x) ((x >> 24) & 0xff)

#define P32(a, b, c, d) ((a << 24) | (b << 16) | (c << 8) | d)

static inline uint32_t rotr32(uint32_t n, unsigned int c)
{
    const unsigned int mask = (32 * sizeof(n) - 1);
    c &= mask;
    return (n >> c) | (n << ((-c) & mask));
}

void charlie_shuffle(uint32_t *x, uint32_t *y)
{
    y[0] = P32(B3(x[3]), B0(x[2]), B1(x[2]), B3(x[2]));
    y[1] = P32(B2(x[3]), B0(x[3]), B2(x[2]), B1(x[3]));
    y[2] = P32(B0(x[0]), B1(x[1]), B1(x[0]), B2(x[0]));
    y[3] = P32(B3(x[0]), B3(x[1]), B0(x[1]), B2(x[1]));
}

void charlie_shuffle_remainder(uint8_t *in, uint8_t *out, size_t len)
{
    if (len == 4)
    {
        out[0] = in[2];
        out[1] = in[3];
        out[2] = in[0];
        out[3] = in[1];
        return;
    }

    if (len < 5)
    {
        if (len != 2)
        {
            for (int i = 0; i < len; i++)
            {
                out[i] = in[i];
            }
        }
        out[0] = in[1];
        out[1] = in[0];

        return;
    }

    if (len == 8)
    {
        out[0] = in[7];
        out[1] = in[4];
        out[2] = in[3];
        out[3] = in[2];
        out[4] = in[1];
        out[5] = in[6];
        out[6] = in[5];
        out[7] = in[0];
        return;
    }

    memcpy(out, in, len);
}

void charlie_decrypt(uint8_t *in, uint8_t *out, size_t len)
{
    size_t remainder = len & 0xf;
    len -= remainder;

    uint32_t *in32 = (uint32_t *)(in);

    for (int i = 0; i < len; i += 0x10)
    {
        uint32_t x[4], y[4];
        x[0] = rotr32(in32[0], 29);
        x[1] = rotr32(in32[1], 25);
        x[2] = rotr32(in32[2], 21);
        x[3] = rotr32(in32[3], 17);
        charlie_shuffle(x, y);

        wle32(out + i + 0x0, rotr32(y[0] ^ K0, 31));
        wle32(out + i + 0x4, rotr32(y[1] ^ K1, 27));
        wle32(out + i + 0x8, rotr32(y[2] ^ K2, 23));
        wle32(out + i + 0xc, rotr32(y[3] ^ K3, 19));

        in32 += 4;
    }
    if (remainder > 0)
    {
        uint8_t tmp[0x10];
        charlie_shuffle_remainder(in + len, tmp, remainder);
        for (int i = 0; i < remainder; i++)
        {
            out[len + i] = tmp[i] ^ g_charlie_key[i];
        }
    }
}

void charlie_encrypt(uint8_t *in, uint8_t *out, size_t len)
{
    size_t remainder = len & 0xf;
    len -= remainder;

    uint32_t *in32 = (uint32_t *)(in);

    for (int i = 0; i < len; i += 0x10)
    {
        uint32_t x[4], y[4];
        x[0] = rotr32(in32[0], 1) ^ K0;
        x[1] = rotr32(in32[1], 5) ^ K1;
        x[2] = rotr32(in32[2], 9) ^ K2;
        x[3] = rotr32(in32[3], 13) ^ K3;
        charlie_shuffle(x, y);

        wle32(out + i + 0x0, rotr32(y[0], 3));
        wle32(out + i + 0x4, rotr32(y[1], 7));
        wle32(out + i + 0x8, rotr32(y[2], 11));
        wle32(out + i + 0xc, rotr32(y[3], 15));

        in32 += 4;
    }
    if (remainder > 0)
    {
        uint8_t tmp[0x10];
        for (int i = 0; i < remainder; i++)
        {
            tmp[i] = in[len + i] ^ g_charlie_key[i];
        }
        charlie_shuffle_remainder(tmp, out + len, remainder);
    }
}

void charlie_encrypt_blob(uint8_t *in, uint8_t *out, size_t len)
{
    assert(len >= 0x10);
    charlie_encrypt(in, out, 0x10);
    if (in[3] & 1)
    {
        size_t remaining = len - 0x10;
        charlie_encrypt(in + 0x10, out + 0x10, (remaining < 0x30) ? remaining : 0x30);
        if (remaining > 0x30)
        {
            memcpy(out + 0x40, in + 0x40, len - 0x40);
        }
    }
    else
    {
        charlie_encrypt(in + 0x10, out + 0x10, len - 0x10);
    }
}

void charlie_decrypt_blob(uint8_t *in, uint8_t *out, size_t len)
{
    charlie_decrypt(in, out, 0x10);
    if (out[3] & 1)
    {
        charlie_decrypt(in + 0x10, out + 0x10, 0x30);
        memcpy(out + 0x40, in + 0x40, len - 0x40);
    }
    else
    {
        charlie_decrypt(in + 0x10, out + 0x10, len - 0x10);
    }
}